const { Product, ProductImage, ProductCategory, Category } = require("../models");
const { Op } = require("sequelize");

exports.handleAddProduct = async (req, res) => {
  const { productName, productPrice, productDescription, productGender, productMainCategory, productSubCategory } = req.body;

  try {
    const existingProduct = await Product.findOne({
      where: {
        name: productName,
      },
    });

    if (existingProduct) {
      return res.status(404).json({
        ok: false,
        msg: "Product already exists",
      });
    }

    // Create the product
    const product = await Product.create({
      name: productName,
      price: productPrice,
      description: productDescription,
      gender: productGender,
    });

    console.log(req.files);
    // Handle multiple images
    const images = req.files; // Assuming you use 'files' for multiple file uploads

    if (!images || images.length === 0) {
      return res.status(400).json({
        ok: false,
        msg: "No images uploaded",
      });
    }

    // Prepare the array of objects to be inserted
    const imageObjects = images.map((image) => {
      return {
        productId: product.id,
        imageUrl: image.filename, // Using the filename generated by Multer
      };
    });

    // Use bulkCreate to insert multiple records at once
    const productImages = await ProductImage.bulkCreate(imageObjects);

    // Create ProductCategory records
    const mainCategoryInstance = await Category.findOne({
      where: { name: productMainCategory },
    });

    console.log(mainCategoryInstance);

    const subCategoryInstance = await Category.findOne({
      where: { name: productSubCategory, parentCategoryId: mainCategoryInstance.id },
    });

    if (!mainCategoryInstance || !subCategoryInstance) {
      return res.status(404).json({
        ok: false,
        msg: "Main category or subcategory not found",
      });
    }

    await ProductCategory.bulkCreate(
      [
        { productId: product.id, categoryId: mainCategoryInstance.id },
        { productId: product.id, categoryId: subCategoryInstance.id },
      ],
      {
        fields: ["productId", "categoryId"], // Specify the fields to include in the bulkCreate operation
      }
    );

    return res.status(201).json({
      ok: true,
      msg: "Product, images, and ProductCategory records added successfully",
      product: product,
      images: productImages,
    });
  } catch (error) {
    console.error(error);
    return res.status(500).json({
      ok: false,
      msg: "Internal server error",
    });
  }
};

exports.handleGetAllProducts = async (req, res) => {
  const limit = parseInt(req.query.limit) || 100;
  const page = parseInt(req.query.page) || 1;
  const sort = req.query.sort; // Get the sorting parameter from the query
  const category = req.query.category; // Get the category filter from the query
  const search = req.query.search; // Get the search query from the query
  const filterBy = req.query.filterBy; // Get the filterBy query from the query

  try {
    const filter = {
      include: [{ model: ProductImage }, { model: ProductCategory, include: [{ model: Category }] }],
      where: {},
    };

    // Apply category filter
    if (category && category !== "All") {
      filter.include[1].where = { name: category }; // Assuming Category model has a 'name' column
    }

    // Apply search query filter using Sequelize's Op.like
    if (search) {
      filter.where.name = {
        [Op.like]: `%${search}%`,
      };
    }

    // Include sorting options
    if (sort) {
      if (sort === "alphabetical-asc") {
        filter.order = [["name", "ASC"]];
      } else if (sort === "alphabetical-desc") {
        filter.order = [["name", "DESC"]];
      }
    }

    if (filterBy) {
      if (filterBy === "price-asc") {
        filter.order = [["price", "ASC"]];
      } else if (filterBy === "price-desc") {
        filter.order = [["price", "DESC"]];
      }
    }

    // Apply pagination
    filter.limit = limit;
    filter.offset = (page - 1) * limit;

    const products = await Product.findAndCountAll(filter);

    if (!products || products.count === 0) {
      return res.status(404).json({
        ok: false,
        message: "No products found!",
      });
    }

    res.status(200).json({
      ok: true,
      pagination: {
        totalData: products.count,
        page: page,
      },
      details: products.rows,
    });
  } catch (error) {
    console.error("Error fetching data:", error);
    res.status(500).json({
      ok: false,
      message: "Internal server error",
    });
  }
};
